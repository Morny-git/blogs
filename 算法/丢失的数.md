### 一个无序数组里有99个不重复正整数，范围从1到100，唯独缺少一个整数。如何找出这个缺失的整数？

1.创建一个hashset  并填充无序数组。再将循环将1-100放入hashet .发现不重复的数就是缺失的整数

时间复杂度是O（2N），空间复杂度是O（N）

2.先算出1+2+3….+100的和，然后依次减去数组里的元素，最后得到的差，就是唯一缺失的整数

时间复杂度是O（N），空间复杂度是O（1）

### 一个无序数组里有若干个正整数，范围从1到100，其中99个整数都出现了偶数次，只有一个整数出现了奇数次（比如1,1,2,2,3,3,4,5,5），如何找到这个出现奇数次的整数？

遍历整个数组，依次做异或运算。由于异或在位运算时相同为0，不同为1，因此所有出现偶数次的整数都会相互抵消变成0，只有唯一出现奇数次的整数会被留下

时间复杂度是O（N），空间复杂度是O（1）

### 一个无序数组里有若干个正整数，范围从1到100，其中98个整数都出现了偶数次，只有两个整数出现了奇数次（比如1,1,2,2,3,4,5,5），如何找到这个出现奇数次的整数？

遍历整个数组，依次做异或运算。由于数组存在两个出现奇数次的整数，所以最终异或的结果，等同于这两个整数的异或结果

这个结果中，至少会有一个二进制位是1（如果都是0，说明两个数相等，和题目不符）。

举个例子，如果最终异或的结果是5，转换成二进制是00000101。此时我们可以选择任意一个是1的二进制位来分析，比如末位。把两个奇数次出现的整数命名为A和B，如果末位是1，说明A和B转为二进制的末位不同，必定其中一个整数的末位是1，另一个整数的末位是0。****

根据这个结论，我们可以把原数组按照二进制的末位不同，分成两部分，一部分的末位是1，一部分的末位是0。由于A和B的末位不同，所以A在其中一部分，B在其中一部分，绝不会出现A和B在同一部分，另一部分没有的情况。

这样一来就简单了，我们的问题又回归到了上一题的情况。

> ```
> public static int findoutMissingDigits(int[] arr) {
>     int result = 0;
>     for (int i : arr) {
>         result ^= i;
>     }
>     return result;
> }
> public static int getShedNum(int num) {
>     int numShift = 1;
>     while((num & numShift) == 0){
>         numShift = numShift << 1;
>         System.out.println(Integer.toBinaryString(numShift));
>     }
>     return numShift;
> }
> public static void main(String[] args) {
>     int[] arr = new int[]{1,1,2,2,3,3,4,5,6,6,7,7};
>     int x = 0;
>     int y = 0;
>     int missingDigits = findoutMissingDigits(arr);
>     int shedNum = getShedNum(missingDigits);
>     for (int i : arr) {
>         if ((i & shedNum) == 0){
>             x ^= i;
>         }else {
>             y ^= i;
>         }
>     }
>     System.out.println(x + " ," + y);//4,5
> }
> ```