### JVM

jvm包含：程序计数器、java虚拟机栈、本地方法栈、堆和方法区。

> 写的非常详细的作者：https://zhuanlan.zhihu.com/p/68145978

![img](..\image\jvm\jvm-7.png)

![830bf1b8cebc45beb0bd83ccd3411167.png](..\image\jvm\jvm-8.png)

- **程序计数器**：每个线程都有一个程序计数器，线程私有的，相互独立。记录当前线程所执行的字节码的**行号指示器**

- **java虚拟机栈**：线程私有。且与线程同生命周期。用于描述java方法执行的内存模型。栈帧存储**局部变量表、操作栈、动态链接和方法出口**等。方法的调用与完成也对应着入栈与出栈。在编译期间分配空间。 -Xss 来指定线程的最大栈空间。

  该区域规定了两种异常：如果线程请求的栈深度大于虚拟机所允许的深度，将抛出**StackOverflowError**异常；如果虚拟机栈可以动态扩展（当前大部分的Java虚拟机都可动态扩展，只不过Java虚拟机规范中也允许固定长度的虚拟机栈），当扩展时无法申请到足够的内存时会抛出**OutOfMemoryError**异常

- **本地方法栈**：虚拟机栈为虚拟机执行Java方法（也就是字节码）服务，而本地方法栈则是为虚拟机使用到的Native方法服务

- **堆**：线程共享。可以物理不连续，逻辑连续。几乎所有的对象实例都在这里分配内存。Java堆是垃圾收集器管理的主要区域，因此也被称为GC堆。现在收集器基本都是采用的分代收集算法，所以Java堆中还可以细分为：**新生代和老年代；再细致一点的有Eden空间、From Survivor空间、To Survivor空间等**，默认8：1：1。会出现OOM.通过-Xmx和-Xms扩展。jdk7中字符串常量池、静态变量也从方法区移到堆区进行存储。

> 运行时常量池：class文件编译后，除了存储类的版本，字段，方法和接口等元数据信息外，还有常量池。这个常量池我们成为 **静态常量池**，代表编译生成的**字面量和符号引用**。当类信息被加载到内存中就会以**运行时常量池**的形式存储在内存中。

- **方法区**：线程共享。存储类的元数据，比如加载的类信息、常量、静态变量、即时编译后的代码。jdk8之前方法区的实现被称为”**永久代**”，永久代和堆是相互隔离的，但它们使用的物理内存。8以及之后由**元数据**实现，使用**JVM内存**，jdk8的时候移除了永久代，使用元空间，使用的**系统内存**，不再与堆连续。这个区域的内存回收目标主要是针对常量池的回收和对类型的卸载，一般来说这个区域的回收“成绩”比较难以令人满意，尤其是类型的卸载，条件相当苛刻.也会出现OOM.

### 调整内存大小：

![img](..\image\jvm\heap.png)

Jdk7及以前中方法区位于永久代中。同时，永久代和堆是相互隔离的，但它们使用的物理内存是连续的

#### 为什么虚拟机栈和本地方法栈是私有的？

为了保证线程中的局部变量不被其他线程访问到，虚拟机栈和本地方法栈是线程私有的。

## JMM

![img](..\image\jvm\jmm.png)

JMM定义了线程和主内存之间的抽象关系：线程之间的共享变量存储在主内存（Main Memory）中，每个线程都有一个私有的本地内存（Local Memory），本地内存中存储了该线程以读/写共享变量的副本。本地内存是JMM的一个抽象概念，并不真实存在。它涵盖了缓存、写缓冲区、寄存器以及其他的硬件和编译器优化。

#### 常量池

- class文件常量池

  class文件中除了有类的版本、字段、方法、接口等描述信息之外。还有常量池（此时还没加载）。用于存放编译期生成的各种**字面量和符号引用**。

  - 字面量：我们常说的常量
    - 文本字符串：string aa = "ds".//ds-字面量
    - final修饰的变量
  - 符号引用：
    - 类、接口、全限定名：例如string类的全限定名：java.lang.string
    - 字段的名称和描述符：类和接口中声明的变量。包括静态变量和实例变量
    - 方法的名称的描述符：方法的参数类型+返回值类型

- 运行时常量池

  上面class文件中的常量池在类加载后进入**方法区**中的运行时常量池。运行时常量池全局共享。在java6时它是方法区的一部分；1.7又把他放到了堆内存中；1.8之后出现了元空间，它又回到了方法区

- 字符串常量池

  用来存储字符串。常量池中的文本字符串会在类加载时进入字符串常量池。

  - jdk7之前字符串常量池在运行时常量池中，也就是**方法区**。此时常量池中存储的是对象。
  - jdk7及以后字符串常量池被移到了**堆**中。此时常量池存储的就是引用了。

> jdk 1.6  永久代	字符串常量池、运行时常量池和静态变量都是在永久代中
>
> jdk 1.7  永久代	运行时常量池、字符串常量池和静态变量被移动到了堆当中；
>
> jdk1.8  元空间	字符串常量池和静态变量在堆当中，运行时常量池、类型信息、常量、字段、方法被移动都了元空间中

#### JDK8为什么要使用元空间取代永久代？

- 最初想让垃圾回收器想管理heap一样管理方法区这样可以省去准们的方法区编辑代码的工作。但是后期永久代容易OOM,且无论是永久代还是年老区谁满了都会触发fullGC。容易造成stw.且字符串常量池放置在永久代容易造成溢出。

- 原先针对方法区的回收主要针对常量池的回收和对类型的卸载。字符串存在永久代中，容易出现性能问题和内存溢出
- 避免OOM异常，因为通常使用PermSize和MaxPermSize设置了永久代的大小上限，但是不是总能设置到刚刚合适的大小
- 使用元空间时，可以加载多少类的元数据就不再由MaxPermSize控制，而是由系统的实际可用空间来控制
- 永久代会为 GC 带来不必要的复杂度，并且回收效率偏低
- 将 HotSpot 与 JRockit 合二为一，JRockit从来没有所谓的永久代，也不需要开发运维人员设置永久代的大小，但是运行良好。同时也不用担心运行性能问题了,在覆盖到的测试中, 程序启动和运行速度降低不超过1%，但是这点性能损失换来了更大的安全保障

#### JDK1.8 新特性

- lamda表达式：

- 函数式接口

- 方法引用和构造器调用

- stream api

- 接口中可以默认方法和静态方法

- 新时间日期api:在java.time包下。

  > LocalDateTime dt = LocalDateTime.now();  
  > DateTimeFormatter dtf = DateTimeFormatter.ofPattern("yyyy-MM-dd hh:mm:ss");         
  > System.out.println(dtf.format(dt));

- hashmap concurrenthashmap

#### 元空间会溢出

- 表现为OutOfMemoryError：MetaSpace。
- 原因：元空间不属于Java虚拟机，使用的是本地内存，存放的是类及方法的一些信息，动态加载类或者频繁加载类信息，但是没有及时卸载，会导致元空间溢出
- 参数设置元空间大小设置由-XX:MaxMetaspaceSize参数调整
- 解决方法：增加元空间大小或删除此参数，让元空间使用内存

#### 对象创建分配内存的两种方式

- 指针碰撞：**假设Java堆中内存是绝对规整的**，所有用过的内存放在一边，空闲的内存放在另一边，中间放着一个指针作为分界点的指示器，那所分配内存就仅仅是把那个指针指向空闲空间那边挪动一段与对象大小相等的距离，这个分配方式叫做“指针碰撞“

- 空闲列表：如果heap的内存不是规整的。已使用的和未使用的相互交错。虚拟机维护一个列表记录哪些内存是可用的。分配对象时从列表中找出一块足够大的空间分配给对象。并更新列表

  > 选择哪种分配方式由Java堆是否规整决定，而Java堆是否规整又由所采用的垃圾收集器是否带有压缩整理功能决定

#### 分配内存时产生的并发问题

- 分配动作做同步处理:CAS
- 分配动作按照线程划分。每个线程分配一个本地缓冲区，分配在缓冲区中进行，缓冲区用完分配新缓冲区的时候再同步锁定

#### 对象访问定位的两种方式

- 句柄访问：heap划分出来一部分内存去来作为句柄池，reference中存储的就是对象的句柄地址。而句柄中则包含对象实例数据的地址和对象类型数据的具体地址信息。句柄访最大的好处是reference中存储着稳定的句柄地址，当对象移动之后（垃圾收集时移动对象是非常普遍的行为），只需要改变句柄中的对象实例地址即可，reference不用修改。

  > object obj = new object();
  >
  > obj——本地引用，存储在栈中的本地变量表中，表示一个引用变量。
  >
  > new object()——实例变量，存储在heap中。同时heap还保存了Object类的信息（对象类型、实现接口、方法等）的具体地址信息，这些地址信息所执行的数据类型存储在方法区中

- 直接指针访问：java堆对象的布局中考虑如何放置访问类型的相关信息（如对象的类型，实现的接口、方法、父类、field等），而reference中存储的就是对象的地址。访问速度快，它减少了一次指针定位的时间开销，由于java是面向对象的语言，在开发中java对象的访问非常的频繁，因此这类开销积少成多也是非常可观的

#### 栈上分配与逃逸分析

#### 内存溢出和内存泄露

#### Object类的finalize()方法

帮助释放资源。

- 自动调用：jvm自动执行，无需手动调用，只能执行一次

- 手动调用：使用System.gc(); 通知JVM执行垃圾回收