	 jvm 中，程序计数器、虚拟机栈、本地方法栈都是随线程而生随线程而灭，栈帧随着方法的进入和退出做入栈和出栈操作，实现了自动的内存清理，因此，我们的内存垃圾回收主要集中于 java 堆和方法区中，在程序运行期间，这部分内存的分配和使用都是动态的

### **对象分配规则**

- 对象优先分配在Eden区，如果Eden区没有足够的空间时，虚拟机执行一次Minor GC。
- 大对象直接进入老年代（大对象是指需要大量连续内存空间的对象）。这样做的目的是避免在Eden区和两个Survivor区之间发生大量的内存拷贝（新生代采用复制算法收集内存）。
- 长期存活的对象进入老年代。虚拟机为每个对象定义了一个年龄计数器，如果对象经过了1次Minor GC那么对象会进入Survivor区，之后每经过一次Minor GC那么对象的年龄加1，知道达到阀值对象进入老年区。
- 动态判断对象的年龄。如果Survivor区中相同年龄的所有对象大小的总和大于Survivor空间的一半，年龄大于或等于该年龄的对象可以直接进入老年代。
- 空间分配担保。每次进行Minor GC时，JVM会计算Survivor区移至老年区的对象的平均大小，如果这个值大于老年区的剩余值大小则进行一次Full GC，如果小于检查HandlePromotionFailure设置，如果true则只进行Monitor GC,如果false则进行Full GC

## 对象存活判断

判断对象是否存活一般有两种方式：

**引用计数**：每个对象有一个引用计数属性，新增一个引用时计数加1，引用释放时计数减1，计数为0时可以回收。此方法简单，无法解决对象相互循环引用的问题。
**可达性分析**（Reachability Analysis）：从GC Roots开始向下搜索，搜索所走过的路径称为引用链。当一个对象到GC Roots没有任何引用链相连时，则证明此对象是不可用的。不可达对象。

在Java语言中，GC Roots包括：

- 虚拟机栈中引用的对象。
- 方法区中类静态属性实体引用的对象。
- 方法区中常量引用的对象。
- 本地方法栈中JNI引用的对象。

## 垃圾收集算法——内存回收的方法论

### 标记 -清除算法（Mark-Sweep）

标记出所有需要回收的对象，在标记完成后统一回收掉所有被标记的对象。

缺点：

- **效率**问题：标记和清除过程的效率都不高
- **空间**问题：产生大量不连续的内存碎片，空间碎片太多可能会导致，当程序在以后的运行过程中需要分配较大对象时无法找到足够的连续内存而不得不提前触发另一次垃圾收集动作

### 复制算法（Copying）

将可用内存按容量划分为大小相等的两块，每次只使用其中的一块。当这一块的内存用完了，就将还存活着的对象复制到另外一块上面，然后再把已使用过的内存空间一次清理掉。

无需考虑内存碎片问题，实现简单，运行高效。缺点：内存缩小为原来的一半，持续复制长生存期的对象则导致效率降低

### 标记-压缩算法（Mark-Compact）

标记过程仍然与“标记-清除”算法一样，后续让所有存活的对象都向一端移动，然后直接清理掉端边界以外的内存

### 分代收集算法（Generational Collection）

Java堆分为新生代和老年代，在新生代中，每次垃圾收集时都发现有大批对象死去，只有少量存活，那就选用复制算法，只需要付出少量存活对象的复制成本就可以完成收集。而老年代中因为对象存活率高、没有额外空间对它进行分配担保，就必须使用“标记-清理”或“标记-整理”算法来进行回收。

## 垃圾收集器——内存回收的具体实现

### Serial收集器

| Serial收集器                                                 | ParNew收集器                                        |
| :----------------------------------------------------------- | --------------------------------------------------- |
| `-XX:+UseSerialGC`                                           | -XX:+UseParNewGC 
-XX:ParallelGCThreads 限制线程数量 |
| 最古老，最稳定以及效率高。但是产生较长的停顿（Stop The World） | Serial收集器的多线程版本                            |
| 新生代、老年代使用串行回收                                   | 新生代并行，老年代串行                              |
| 新生代：复制  老年代：标记-压缩                              | 新生代：复制  老年代：标记-压缩                     |

| Parallel收集器                                               | Parallel Old收集器              |
| :----------------------------------------------------------- | ------------------------------- |
| -XX:+UseParallelGC                                           | -XX:+UseParallelOldGC           |
| 类似ParNew收集器，关注系统的吞吐量。<br />动态调整这些参数以提供最合适的停顿时间或最大的吞吐量。<br />也可以通过参数控制GC的时间不大于多少毫秒或者比例 | Parallel收集器的老年代版本      |
| Parallel收集器+ 老年代串行                                   | Parallel收集器+ 老年代并行      |
| 新生代：复制  老年代：标记-压缩                              | 新生代：复制  老年代：标记-压缩 |

### CMS收集器（Concurrent Mark Sweep）

是一种以获取最短回收停顿时间为目标的收集器。基于“**标记-清除**”算法实现。4个步骤，包括：

- 初始标记（CMS initial mark）-STW. 标记一下GC Roots能直接关联到的对象，速度很快
- 并发标记（CMS concurrent mark）-STW。 进行GC Roots Tracing的过程
- 重新标记（CMS remark）。修正并发标记期间，因用户程序继续运作而导致标记产生变动的那一部分对象的标记记录。比初始长，但是远小于并发。
- 并发清除（CMS concurrent sweep）

由于整个过程中耗时最长的并发标记和并发清除过程中，收集器线程都可以与用户线程一起工作，所以总体上来说，CMS收集器的内存回收过程是与用户线程一起并发地执行。老年代收集器（新生代使用ParNew）

**优点**: 并发收集、低停顿
**缺点**: 产生大量空间碎片、并发阶段会降低吞吐量

参数控制：

`-XX:+UseConcMarkSweepGC` 使用CMS收集器
`-XX:+ UseCMSCompactAtFullCollection` Full GC后，进行一次碎片整理；整理过程是独占的，会引起停顿时间变长
`-XX:+CMSFullGCsBeforeCompaction` 设置进行几次Full GC后，进行一次碎片整理
`-XX:ParallelCMSThreads` 设定CMS的线程数量（一般情况约等于可用CPU数量）

### G1收集器

1. **空间整合**：G1收集器采用**标记整理**算法，不会产生内存空间碎片。分配大对象时不会因为无法找到连续空间而提前触发下一次GC。
2. **可预测停顿**：**降低停顿时间**是G1和CMS的共同关注点，但G1除了追求低停顿外，还能建立**可预测的停顿时间**模型，能让使用者明确指定在一个长度为N毫秒的时间片段内，消耗在垃圾收集上的时间不得超过N毫秒，这几乎已经是实时Java（RTSJ）的垃圾收集器的特征了。

G1算法将堆划分为若干个区域（Region），它仍然属于分代收集器。在G1中，还有一种特殊的区域，叫Humongous区域。 如果一个对象占用的空间超过了分区容量50%以上，G1收集器就认为这是一个巨型对象。这些巨型对象，默认直接会被分配在年老代，但是如果它是一个短期存在的巨型对象，就会对垃圾收集器造成负面影响。为了解决这个问题，G1划分了一个Humongous区，它用来专门存放巨型对象。如果一个H区装不下一个巨型对象，那么G1会寻找连续的H分区来存储。为了能找到连续的H区，有时候不得不启动Full GC

**G1 Young GC**

Young GC主要是对Eden区进行GC，它在Eden空间耗尽时会被触发。在这种情况下，Eden空间的数据移动到Survivor空间中，如果Survivor空间不够，Eden空间的部分数据会直接晋升到年老代空间。Survivor区的数据移动到新的Survivor区中，也有部分数据晋升到老年代空间中。最终Eden空间的数据为空，GC停止工作，应用线程继续执行

G1的新生代收集跟ParNew类似，当新生代占用达到一定比例的时候，开始出发收集。和CMS类似，G1收集器收集老年代对象会有短暂停顿

收集步骤：

1、标记阶段，会有STW，并且会触发一次普通Mintor GC。对应GC log:GC pause (young) (inital-mark)

2、Root Region Scanning，程序运行过程中会回收survivor区(存活到老年代)，这一过程必须在young GC之前完成。

3、Concurrent Marking，在整个堆中进行并发标记(和应用程序并发执行)，此过程可能被young GC中断。在并发标记阶段，若发现区域对象中的所有对象都是垃圾，那个这个区域会被立即回收(图中打X)。同时，并发标记过程中，会计算每个区域的对象活性(区域中存活对象的比例)。

4、Remark, 再标记，会有短暂停顿(STW)。再标记阶段是用来收集 并发标记阶段 产生新的垃圾(并发阶段和应用程序一同运行)；G1中采用了比CMS更快的初始快照算法:snapshot-at-the-beginning (SATB)。

5、Copy/Clean up，多线程清除失活对象，会有STW。G1将回收区域的存活对象拷贝到新区域，清除Remember Sets，并发清空回收区域并把它返回到空闲区域链表中。

6、复制/清除过程后。回收区域的活性对象已经被集中回收到深蓝色和深绿色区域

`-XX:+UnlockExperimentalVMOptions` `-XX:+UseG1GC` #开启； `-XX:MaxGCPauseMillis=50` #暂停时间目标； `-XX:GCPauseIntervalMillis=200` #暂停间隔目标； `-XX:+G1YoungGenSize=512m` #年轻代大小； `-XX:SurvivorRatio=6` #幸存区比例





**三色标记算法**

提到并发标记，我们不得不了解并发标记的三色标记算法。它是描述追踪式回收器的一种有用的方法，利用它可以推演回收器的正确性。 首先，我们将对象分成三种类型的。

- 黑色:根对象，或者该对象与它的子对象都被扫描
- 灰色:对象本身被扫描,但还没扫描完该对象中的子对象
- 白色:未被扫描对象，扫描完成所有对象之后，最终为白色的为不可达对象，即垃圾对象