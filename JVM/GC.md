	 jvm 中，程序计数器、虚拟机栈、本地方法栈都是随线程而生随线程而灭，栈帧随着方法的进入和退出做入栈和出栈操作，实现了自动的内存清理，因此，我们的内存垃圾回收主要集中于 java 堆和方法区中，在程序运行期间，这部分内存的分配和使用都是动态的

垃圾回收机制主要解决那些问题？哪些可以回收？什么时候回收？怎么回收？

### 哪些可以回收？

对堆回收前，对死亡的进行回收

#### 对象存活判断

判断对象是否存活一般有两种方式：

**引用计数**：每个对象有一个引用计数属性，新增一个引用时计数加1，引用释放时计数减1，计数为0时可以回收。此方法简单，无法解决对象相互循环引用的问题。
**可达性分析**（Reachability Analysis）：从GC Roots开始向下搜索，搜索所走过的路径称为引用链。当一个对象到GC Roots没有任何引用链相连时，则证明此对象是不可用的。不可达对象。

在Java语言中，GC Roots包括：

- 虚拟机栈中引用的对象。
- 方法区中类静态属性实体引用的对象。
- 方法区中常量引用的对象。
- 本地方法栈中JNI引用的对象。

#### 方法区如何判断是否需要回收

**方法区**是否GC和heap不一样。方法区主要回收的内容有：**废弃常量**和**无用的类**。对于**废弃常量**也可通过引用的**可达性**来判断，但是对于**无用的类**则需要同时满足下面3个条件：

- 该类所有的实例都已经被回收，也就是Java堆中不存在该类的任何实例；
- 加载该类的ClassLoader已经被回收；
- 该类对应的java.lang.Class对象没有在任何地方被引用，无法在任何地方通过反射访问该类的方法。

### 什么时候回收？

对象宣告正式死亡之前要进行两次标记

 第一次标记：可达性分析中认定为不可达对象

第二次标记：重新筛选，筛选看此对象是否有必要执行finalize()方法。在finalize()方法中没有重新与引用链建立关联关系的，将被进行第二次标记。
第二次标记成功的对象将真的会被回收，如果对象在finalize()方法中重新与引用链建立了关联关系，那么将会逃离本次回收，继续存活。

#### 四种引用状态

强引用：obj o = new obj().不进行GC

软引用：SoftReference.有用但并非必须的对象.内存溢出异常之前GC

弱引用：WeakReference.非必须对象。每次GC时必清理

虚引用：PhantomReference。GC时收到系统通知

### 怎么回收？

#### 回收流程

- 对象优先分配在**Eden**区，如果Eden区没有足够的**空间**时，虚拟机执行一次**Minor GC**，释放掉不活跃的对象，**存活**下来的**复制**到**survivor0**,同时**清空Eden**.。
- eden 再次满了，触发MinorGC ，将eden和s0中存活下来的**复制到s1**，清空eden和s0.**年龄+1**.如此循环
  - 默认年龄大于15的对象，直接进入老年代。或大对象直接进入老年代
- 老年代满了，触发Full GC.试方老年代和年轻代
- 还是没有空间，则OOM

#### 垃圾收集算法——内存回收的方法论

##### 标记 -清除算法（Mark-Sweep）

标记出所有需要回收的对象，在标记完成后统一回收掉所有被标记的对象。

缺点：

- **效率**问题：标记和清除过程的效率都不高
- **空间**问题：产生大量不连续的内存**碎片**，空间碎片太多可能会导致，当程序在以后的运行过程中需要分配较大对象时无法找到足够的连续内存而不得不提前触发另一次垃圾收集动作

##### 复制算法（Copying）

将可用内存按容量划分为大小相等的两块，每次只使用其中的一块。当这一块的内存用完了，就将还存活着的对象复制到另外一块上面，然后再把已使用过的内存空间一次清理掉。

无需考虑内存碎片问题，实现简单，运行**高效**。缺点：**内存缩小**为原来的一半，持续复制长生存期的对象则导致效率降低

##### 标记-压缩算法（Mark-Compact）

标记过程仍然与“标记-清除”算法一样，后续让所有存活的对象都向一端移动，然后直接清理掉端边界以外的内存

##### 分代收集算法（Generational Collection）

Java堆分为新生代和老年代，在新生代中，每次垃圾收集时都发现有大批对象死去，只有少量存活，那就选用复制算法，只需要付出少量存活对象的复制成本就可以完成收集。而老年代中因为对象存活率高、没有额外空间对它进行分配担保，就必须使用“标记-清理”或“标记-整理”算法来进行回收。

#### 垃圾收集器——内存回收的具体实现

![img](..\image\jvm\gc.png)

|  Serial Old  | Serial    ParNew    Parallel Sacavenge |
| :----------: | :------------------------------------: |
|     CMS      |      ParNew    Parallel Sacavenge      |
| Parallel Old |           Parallel Sacavenge           |

#### 新生代垃圾回收器

**吞吐量=运行用户代码时间/（运行用户代码时间+垃圾收集时间）**虚拟机总运行100分钟，垃圾收集1分钟，那吞吐量就是99%

| Serial                                                       | ParNew                                                      | Parallel                                                     |
| ------------------------------------------------------------ | ----------------------------------------------------------- | ------------------------------------------------------------ |
| `-XX:+UseSerialGC`                                           | -XX:+UseParNewGC <br />-XX:ParallelGCThreads 限制gc线程数量 | -XX:+UseParallelGC<br />-XX:MaxGCPauseMillis  “STW的时间<br />-XX:GCTimeRatio：吞吐量大小 |
| 复制算法的单线程的收集器                                     | Serial收集器的多线程版本，复制算法                          | 并行的多线程                                                 |
| 最古老稳定以及效率高(因为没有线程开销)<br />产生较长的停顿(STW) | cpu多的情况下有优势。STW                                    | **可控制的吞吐量**                                           |
| 运行在**Client**模式下的**默认**的收集器                     | **Server**模式下的**首选**的的收集器                        | **Server**模式下的**默认**垃圾收集器                         |

#### 老年代垃圾回收器

| Serial Old                  | **Parallel Old**                  | CMS                       | G1                      |
| --------------------------- | --------------------------------- | ------------------------- | ----------------------- |
| **Serial的老年代版本**      | **Parallel的老年代版本**          |                           | 不区分年轻和老年        |
| -XX:+UseSeriallOldGC        | -XX:+UseParallelOldGC             | `-XX:+UseConcMarkSweepGC` |                         |
| **单线程**和“**标记-整理**” | **多线程和“标记-整理”**           | **多线程和标记 - 清除**   | **多线程和“标记-整理”** |
|                             | 注重吞吐量                        | **最短回收停顿时间**      | **可预测的停顿**        |
| Client模式下的虚拟机        | 在注重吞吐量以及CPU资源敏感的场合 |                           | 分代思想                |

#### CMS收集器（Concurrent Mark Sweep）

是一种以获取最短回收停顿时间为目标的收集器。基于“**标记-清除**”算法实现。4个步骤，包括：

- 初始标记（CMS initial mark）-STW. 标记一下GC Roots能直接关联到的对象，速度很快
- 并发标记（CMS concurrent mark）。 进行GC Roots Tracing的过程
- 重新标记（CMS remark）-STW。修正并发标记期间，因用户程序继续运作而导致标记产生变动的那一部分对象的标记记录。比初始长，但是远小于并发。
- 并发清除（CMS concurrent sweep）

由于整个过程中耗时**最长**的**并发标记和并发清除**过程中，收集器线程都可以与用户线程一起工作，所以总体上来说，CMS收集器的内存**回收过程是与用户线程一起并发**地执行。老年代收集器

**优点**: 并发收集、低停顿
**缺点**: 产生大量空间碎片、并发阶段会降低吞吐量

参数控制：

`-XX:+UseConcMarkSweepGC` 使用CMS收集器
`-XX:+ UseCMSCompactAtFullCollection` Full GC后，进行一次碎片整理；整理过程是独占的，会引起停顿时间变长
`-XX:+CMSFullGCsBeforeCompaction` 设置进行几次Full GC后，进行一次碎片整理
`-XX:ParallelCMSThreads` 设定CMS的线程数量（一般情况约等于可用CPU数量）

![img](..\image\jvm\cms.png)

#### G1收集器

1. **空间整合**：G1收集器采用**标记整理**算法，不会产生内存空间碎片。分配大对象时不会因为无法找到连续空间而提前触发下一次GC。
2. **可预测停顿**：**降低停顿时间**是G1和CMS的共同关注点，但G1除了追求低停顿外，还能建立**可预测的停顿时间**模型，能让使用者明确指定在一个长度为N毫秒的时间片段内，消耗在垃圾收集上的时间不得超过N毫秒，这几乎已经是实时Java（RTSJ）的垃圾收集器的特征了。

G1算法将堆划分为若干个区域（Region），它仍然属于分代收集器。在G1中，还有一种特殊的区域，叫Humongous区域。 如果一个对象占用的空间超过了分区容量50%以上，G1收集器就认为这是一个巨型对象。这些巨型对象，默认直接会被分配在年老代，但是如果它是一个短期存在的巨型对象，就会对垃圾收集器造成负面影响。为了解决这个问题，G1划分了一个Humongous区，它用来专门存放巨型对象。如果一个H区装不下一个巨型对象，那么G1会寻找连续的H分区来存储。为了能找到连续的H区，有时候不得不启动Full GC

**G1 Young GC**

G1的新生代收集跟ParNew类似，当新生代占用达到一定比例的时候，开始**并发收集**。和CMS类似，G1收集器收集老年代对象会有短暂停顿

收集步骤：

1、标记阶段，会有STW，并且会触发一次普通Mintor GC。对应GC log:GC pause (young) (inital-mark)

2、Root Region Scanning，程序运行过程中会回收survivor区(存活到老年代)，这一过程必须在young GC之前完成。

3、并发标记，在整个堆中进行并发标记(和应用程序并发执行)，此过程可能被young GC中断。在并发标记阶段，若发现区域对象中的所有对象都是垃圾，那个这个区域会被立即回收(图中打X)。同时，并发标记过程中，会计算每个区域的对象活性(区域中存活对象的比例)。

4、Remark, 再标记，会有短暂停顿(STW)。再标记阶段是用来收集 并发标记阶段 产生新的垃圾(并发阶段和应用程序一同运行)；G1中采用了比CMS更快的初始快照算法:snapshot-at-the-beginning (SATB)。

5、Copy/Clean up，多线程清除失活对象，会有STW。G1将回收区域的存活对象拷贝到新区域，清除Remember Sets，并发清空回收区域并把它返回到空闲区域链表中。

6、复制/清除过程后。回收区域的活性对象已经被集中回收到深蓝色和深绿色区域

`-XX:+UnlockExperimentalVMOptions` `-XX:+UseG1GC` #开启； `-XX:MaxGCPauseMillis=50` #暂停时间目标； `-XX:GCPauseIntervalMillis=200` #暂停间隔目标； `-XX:+G1YoungGenSize=512m` #年轻代大小； `-XX:SurvivorRatio=6` #幸存区比例

**三色标记算法**

提到并发标记，我们不得不了解并发标记的三色标记算法。它是描述追踪式回收器的一种有用的方法，利用它可以推演回收器的正确性。 首先，我们将对象分成三种类型的。

- 黑色:根对象，或者该对象与它的子对象都被扫描
- 灰色:对象本身被扫描,但还没扫描完该对象中的子对象
- 白色:未被扫描对象，扫描完成所有对象之后，最终为白色的为不可达对象，即垃圾对象

#### 内存溢出和内存泄露

- 内存溢出： out of memory。申请内存时，没有足够的内存空间供其使用
- 内存泄露：memory leak。申请内存后，无法释放已申请的内存空间。内存泄露会导致内存溢出

















> 引用：https://blog.csdn.net/ctwy291314/article/details/84987977