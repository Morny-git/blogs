#### redis速度能达到10w+/s

- 完全基于内存
- 数据结构简单
- 采用单线程，避免了不必要的上下文切换和竞争条件，也不存在多进程或者多线程导致的切换而消耗 **CPU**，不用去考虑各种锁的问题，不存在加锁释放锁操作，没有因为可能出现死锁而导致的性能消耗
- 使用多路I/O复用非阻塞模型
- 使用自己的VM，没使用系统函数

为了更好的使用多核服务器的性能，可使用启动多个实例。

#### redis如何实现持久化

持久化有两种方式：

RDB：进行周期性的持久化，默认5分钟，会生成多个数据文件，代表某一时刻redis里面的数据。对**性能影响小**，因为只fork出一个子进程做持久化，恢复速度比AOF快。

RDB是快照文件，因为是周期性的持久化，所以可能会丢失5分钟的数据，AOF最多丢失1s.**数据完整性**不好。而且文件大，在fork出子进程时会暂停几毫秒甚至几秒，如果此时有秒杀活动就会出问题。

AOF：采用append-only 对每条写入命令作为日志，没有磁盘寻址开销，速度快。AOF 1s/1次通过后台的线程fsync操作，所以最多丢1s数据。**文件大**但是恢复速度慢。

两种机制全部开启的时候，Redis在重启的时候会默认使用AOF去重新构建数据，因为AOF的数据是比RDB更完整的

恢复数据时，第一时间用RDB恢复，然后AOF做数据补全。

#### 高可用

持久化可以保证数据不丢失，哨兵+主从可以保证集群的高可用。

哨兵必须用三个实例保证健壮性，哨兵的主要功能：

- 集群监控：负责监控  master  slave是否正常
- 消息通知：如果某个 **Redis** 实例有故障，那么哨兵负责发送消息作为报警通知给管理员
- 故障转移：如果 master node 挂掉了，会自动转移到 slave node 上
- 配置中心：如果故障转移发生了，通知 client 客户端新的 master 地址

#### 主从如何同步

启动一个slave,会发送一个psynci命令给master,如果slave是第一次连接到master,会触发全量复制。master就会启动一个线程生成RDB快照，还会将新的写请求都缓存到内存中，RDB文件生成后，master将RDB发送给slave.slave拿到后第一时间写入到本地磁盘，然后加载到内存，然后master会把内存里面缓存的那些新命名都发给slave。

#### 过期策略

定期删除+惰性删除

##### 内存淘汰机制  LRU RANDOM LFU

- **noeviction**:当内存使用超过配置的时候会返回错误，不会驱逐任何键
- allkeys-lru：如果key过多，使用lru删除最久没使用的key
- volatile-lru：如果key过多，从设置过期时间的key中使用lru删除最久没使用的key
- allkeys-random：如果key过多，随机删除最久没使用的key
- volatile-random：如果key过多，从设置过期时间的key中随机删除最久没使用的key
- allkeys-lfu：删除使用频率最少的key
- volatile-lfu：删除设置过期时间中使用频率最少的key
- colatile-ttl：删除设置过期时间中马上要过期的key

#### 持久化

客户端发送写操作---服务端接收到数据---服务端调用write，写到缓冲区---os将缓冲区的数据写入到磁盘缓存中---磁盘控制器将数据写入到物理戒指中
RDB:将数据写入到disk.dump.rdb
三种机制来触发：
save：阻塞其他命令，执行完成，如果存在老的rdb,用新的替换掉。该方式不靠谱
bgsave：后台异步执行快照操作，其他命令依然可以执行。一般采用该方式
自动化：由配置文件触发。：a.save m n 存在m秒内触发了n次修改，自动触发bgsave
							b.stop-writes-on-bgsave-error:默认yes
							c.rdbcompression :yes是否压缩
							d.rdbchecksum :yes   使用crc64算法校验是否正确，损失10%性能
							e.dbfilename 
							f.dir  存放路径
优势：rdb文件紧凑，全量备份      生成rdb文件时，fork进来一个进程，不需要主进程进行io    恢复速度比aof快
劣势：一次全量备份。久化期间修改的数据不会被保存，可能丢失数据
							
AOF:将受到的谢明令都通过write函数追加到文件中。也就是日志记录。但是文件会越来越大，为了压缩。提供了gbrewriteaof命令，将内存中的数据保存到临时文件中，同时fork出一条新进程将文件重写
触发机制：always:性能差 数据完整
			everysec:一步操作，每秒记录。如果一秒内宕机，数据缺失
			no:从不同步
优势：每秒进行备份。数据最多丢失一秒   没有磁盘寻址，性能高，文件不易被破坏   即便是过大，也会重写 不影响使用
劣势：文件更大。写的qps低









