#### redis速度能达到10w+/s

- 完全基于内存
- 数据结构简单
- 采用单线程，避免了不必要的上下文切换和竞争条件，也不存在多进程或者多线程导致的切换而消耗 **CPU**，不用去考虑各种锁的问题，不存在加锁释放锁操作，没有因为可能出现死锁而导致的性能消耗
- 使用多路I/O复用非阻塞模型
- 使用自己的VM，没使用系统函数

为了更好的使用多核服务器的性能，可使用启动多个实例。

#### redis如何实现持久化

持久化有两种方式：

RDB：进行周期性的持久化，默认5分钟，会生成多个数据文件，代表某一时刻redis里面的数据。对**性能影响小**，因为只fork出一个子进程做持久化，恢复速度比AOF快。

RDB是快照文件，因为是周期性的持久化，所以可能会丢失5分钟的数据，AOF最多丢失1s.**数据完整性**不好。而且文件大，在fork出子进程时会暂停几毫秒甚至几秒，如果此时有秒杀活动就会出问题。

AOF：采用append-only 对每条写入命令作为日志，没有磁盘寻址开销，速度快。AOF 1s/1次通过后台的线程fsync操作，所以最多丢1s数据。**文件大**但是恢复速度慢。

两种机制全部开启的时候，Redis在重启的时候会默认使用AOF去重新构建数据，因为AOF的数据是比RDB更完整的

恢复数据时，第一时间用RDB恢复，然后AOF做数据补全。

#### 高可用

持久化可以保证数据不丢失，哨兵+主从可以保证集群的高可用。

哨兵必须用三个实例保证健壮性，哨兵的主要功能：

- 集群监控：负责监控  master  slave是否正常
- 消息通知：如果某个 **Redis** 实例有故障，那么哨兵负责发送消息作为报警通知给管理员
- 故障转移：如果 master node 挂掉了，会自动转移到 slave node 上
- 配置中心：如果故障转移发生了，通知 client 客户端新的 master 地址

#### 主从如何同步

**全量同步**：一般发生再slave初始化阶段

- slave 连接master ,发送sync命令
- master接收到sync后，开始执行bgsave命令生成rd文件，并使用缓冲区记录此后的所有写命令
- bgsave完成后，想所有的salve发送rdb文件，并在发送期间继续记录被执行的写命令
- slave接收到rdb后，丢弃所有的旧数据，载入收到的rdb
- master发送完rdb后，开始向slave发送缓冲区的命令
- slave完成载入rdb后，开始接受master发送过来的写命令并执行。

**增量同步：**slave初始化后，正常工作时，master发生的写操作同步给slave

主服务器每执行一个写命令就会向从服务器发送相同的写命令，从服务器接收并执行收到的写命令

#### 过期策略

定期删除+惰性删除

##### 内存淘汰机制  LRU RANDOM LFU

- **noeviction**:当内存使用超过配置的时候会返回错误，不会驱逐任何键
- allkeys-lru：如果key过多，使用lru删除最久没使用的key
- volatile-lru：如果key过多，从设置过期时间的key中使用lru删除最久没使用的key
- allkeys-random：如果key过多，随机删除最久没使用的key
- volatile-random：如果key过多，从设置过期时间的key中随机删除最久没使用的key
- allkeys-lfu：删除使用频率最少的key
- volatile-lfu：删除设置过期时间中使用频率最少的key
- colatile-ttl：删除设置过期时间中马上要过期的key

#### 持久化

客户端发送写操作---服务端接收到数据---服务端调用write，写到缓冲区---os将缓冲区的数据写入到磁盘缓存中---磁盘控制器将数据写入到物理戒指中
**RDB**:将数据写入到disk.dump.rdb
三种机制来触发：
save：阻塞其他命令，执行完成，如果存在老的rdb,用新的替换掉。该方式不靠谱

bgsave：后台异步执行快照操作，其他命令依然可以执行。一般采用该方式

自动化：由配置文件触发。

​							a.save m n 存在m秒内触发了n次修改，自动触发bgsave

​							b.stop-writes-on-bgsave-error:默认yes

​							c.rdbcompression :yes是否压缩

​							d.rdbchecksum :yes   使用crc64算法校验是否正确，损失10%性能

​							e.dbfilename 

​							f.dir  存放路径

**优势**：rdb文件紧凑，全量备份      生成rdb文件时，fork进来一个进程，不需要主进程进行io    恢复速度比aof快
**劣势**：一次全量备份。久化期间修改的数据不会被保存，可能丢失数据

​			由于通过fork出子进程协助完成持久胡啊，内存中的数据被克隆了一i分，大致2倍的膨胀性需要考虑，当数据集比较大时，fork动作会导致服务暂停几百毫秒或者1s.

**AOF**:redis执行命令，将数据写入内存，然后记录日志。将命令都通过write函数追加到文件中。也就是日志记录。但是文件会越来越大，为了压缩。提供了gbrewriteaof命令，将内存中的数据保存到临时文件中，同时fork出一条新进程将文件重写
**触发机制**：

- always:性能差 数据完整

- everysec:每个命令执行完，把日志写入到aof的缓冲区，每隔一秒缓冲区的内容写入磁盘。如果一秒内宕机，数据缺失
- no:系统控制，大多数linux系统，每隔30s进行一次fsync

总结：高性能就用no,高可靠用always.如果允许一点损失用everysec

**优势**：

- 每秒进行备份。数据最多丢失一秒   没有磁盘寻址，性能高，文件不易被

  破坏   即便是过大，也会重写 不影响使用。

- 命令执行后才记录日志不会阻塞当前操作，也避免了记录错误命令的情况

**劣势**：

- 文件更大。恢复速度慢

- 根据同步策略不同，AOF写的qps低与RDB，但是no策略的效率和RDB一样高。

#### **aof重写**rewite

随着时间的推移，aof的日志会越来越大，需要对aof进行瘦身。redis提供了bgrewriteaof 指令用于对aof日志进行瘦身。

原理就是fork一个子进程对**内存**进行遍历，只保留恢复数据的最小指令集。例如set k1 v1,set k1 v2.只保留set k1 v2.根据键值的最新状态为它涩会给你成对应的写入命令，这样一个key值对应一个命令。

重写AOF没有读取旧的AOF，而是读取整个内存的数据，用命令重写了一个新的AOF。

步骤：

- Redis 执行`fork()`，现在同时拥有父进程和子进程
- 子进程开始将新 AOF 文件的内容写入到临时文件
- 对于所有新执行的写入命令，父进程一边将它们累积到一个内存缓存中，一边将这些改动追加到现有 AOF 文件的末尾：这样即使在重写的中途发生停机，现有的 AOF 文件也还是安全的
- 当子进程完成重写工作时，它给父进程发送一个信号，父进程在接收到信号之后，将内存缓存中的所有数据追加到新 AOF 文件的末尾
-  Redis 原子地用新文件替换旧文件，之后所有命令都会直接追加到新 AOF 文件的末尾

**触发机制：**默认是上次rewrite后的一倍大小且>64M

#### bgsave是单线程的么？

是的。bgsave 子进程是由主线程 fork 生成的，可以共享主线程的所有内存数据。如果

主线程要修改一块数据，那么，这块数据就会被复制一份，生成该数据的副本。

然后，bgsave 子进程会把这个副本数据写入 RDB 文件，而在这个过程中，主线

程仍然可以直接修改原来的数据。



> 引用：https://www.163.com/dy/article/FVG7JT8V0531A3HQ.html







