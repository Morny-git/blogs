#### redis速度能达到10w+/s

- 完全基于内存
- 数据结构简单
- 采用单线程，避免了不必要的上下文切换和竞争条件，也不存在多进程或者多线程导致的切换而消耗 **CPU**，不用去考虑各种锁的问题，不存在加锁释放锁操作，没有因为可能出现死锁而导致的性能消耗
- 使用多路I/O复用非阻塞模型
- 使用自己的VM，没使用系统函数

为了更好的使用多核服务器的性能，可使用启动多个实例。

#### redis如何实现持久化

持久化有两种方式：

RDB：进行周期性的持久化，默认5分钟，会生成多个数据文件，代表某一时刻redis里面的数据。对**性能影响小**，因为只fork出一个子进程做持久化，恢复速度比AOF快。

RDB是快照文件，因为是周期性的持久化，所以可能会丢失5分钟的数据，AOF最多丢失1s.**数据完整性**不好。而且文件大，在fork出子进程时会暂停几毫秒甚至几秒，如果此时有秒杀活动就会出问题。

AOF：采用append-only 对每条写入命令作为日志，没有磁盘寻址开销，速度快。AOF 1s/1次通过后台的线程fsync操作，所以最多丢1s数据。**文件大**但是恢复速度慢。

两种机制全部开启的时候，Redis在重启的时候会默认使用AOF去重新构建数据，因为AOF的数据是比RDB更完整的

恢复数据时，第一时间用RDB恢复，然后AOF做数据补全。

#### 高可用

持久化可以保证数据不丢失，哨兵+主从可以保证集群的高可用。

哨兵必须用三个实例保证健壮性，哨兵的主要功能：

- 集群监控：负责监控  master  slave是否正常
- 消息通知：如果某个 **Redis** 实例有故障，那么哨兵负责发送消息作为报警通知给管理员
- 故障转移：如果 master node 挂掉了，会自动转移到 slave node 上
- 配置中心：如果故障转移发生了，通知 client 客户端新的 master 地址

#### 主从如何同步

启动一个slave,会发送一个psynci命令给master,如果slave是第一次连接到master,会触发全量复制。master就会启动一个线程生成RDB快照，还会将新的写请求都缓存到内存中，RDB文件生成后，master将RDB发送给slave.slave拿到后第一时间写入到本地磁盘，然后加载到内存，然后master会把内存里面缓存的那些新命名都发给slave。

#### 过期策略

定期删除+惰性删除

##### 内存淘汰机制  LRU RANDOM LFU

- **noeviction**:当内存使用超过配置的时候会返回错误，不会驱逐任何键
- allkeys-lru：如果key过多，使用lru删除最久没使用的key
- volatile-lru：如果key过多，从设置过期时间的key中使用lru删除最久没使用的key
- allkeys-random：如果key过多，随机删除最久没使用的key
- volatile-random：如果key过多，从设置过期时间的key中随机删除最久没使用的key
- allkeys-lfu：删除使用频率最少的key
- volatile-lfu：删除设置过期时间中使用频率最少的key
- colatile-ttl：删除设置过期时间中马上要过期的key













