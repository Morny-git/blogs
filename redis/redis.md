#### redis I/O多路复用

redis  是单线程的，所有的操作都按照顺序线性执行。由于读写操作等待用户输入或输出都是阻塞的，一般情况下往往不能直接返回，某一个文件的阻塞导致整个线程都无法对其他用户提供服务。多路复用可以解决这个问题。将用户socket对应的fd注册进epoll，然后epoll帮你监听哪些socket上有消息到达，这样就避免了大量的无用操作。

redis的io模型主要是基于epoll实现的，不过它也提供了 select和kqueue的实现，默认采用epoll。

1. epoll 没有最大并发连接的限制，上限是最大可以打开文件的数目，这个数字一般远大于 2048, 

2. 效率提升， Epoll 最大的优点就在于它 **只管你“活跃”的连接** ，而跟连接总数无关

3. 内存拷贝， Epoll 在这点上使用了“ **共享内存**  ”，这个内存拷贝也省略了

#### redis 为什么速度快

CPU的速度是远大于内存的速度的，同时内存的速度也是远大于硬盘的速度。redis的操作都是基于内存的，绝大部分请求是纯粹的内存操作，非常迅速，使用单线程可以省去多线程时CPU上下文会切换的时间，也不用去考虑各种锁的问题，不存在加锁释放锁操作，没有死锁问题导致的性能消耗。

