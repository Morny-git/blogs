#### redis I/O多路复用

redis  是单线程的，所有的操作都按照顺序线性执行。由于读写操作等待用户输入或输出都是阻塞的，一般情况下往往不能直接返回，某一个文件的阻塞导致整个线程都无法对其他用户提供服务。多路复用可以解决这个问题。将用户socket对应的fd注册进epoll，然后epoll帮你监听哪些socket上有消息到达，这样就避免了大量的无用操作。

redis的io模型主要是基于epoll实现的，不过它也提供了 select和kqueue的实现，默认采用epoll。

1. epoll 没有最大并发连接的限制，上限是最大可以打开文件的数目，这个数字一般远大于 2048, 

2. 效率提升， Epoll 最大的优点就在于它 **只管你“活跃”的连接** ，而跟连接总数无关

3. 内存拷贝， Epoll 在这点上使用了“ **共享内存**  ”，这个内存拷贝也省略了

#### redis 为什么速度快

CPU的速度是远大于内存的速度的，同时内存的速度也是远大于硬盘的速度。redis的操作都是基于内存的，绝大部分请求是纯粹的内存操作，非常迅速，使用单线程可以省去多线程时CPU上下文会切换的时间，也不用去考虑各种锁的问题，不存在加锁释放锁操作，没有死锁问题导致的性能消耗。

#### **aof重写**

随着时间的推移，aof的日志会越来越长，日志会越来越大，需要对aof进行瘦身
redis提供了bgrewriteaof指令用于对aof日志进行瘦身，原理就是开辟一个子进程对内存进行遍历，转换成一系列的redis的操作指令，序列化到一个新的aof日志文件中，序列化完毕后再将操作期间发生的增量aof日志追加到这个新的aof日志文件中，追加完毕后就立即替换旧的aof，由于新的aof文件去除了许多没有用占用空间的多余东西，所以新aof文件会比旧的aof占用空间容量要小很多